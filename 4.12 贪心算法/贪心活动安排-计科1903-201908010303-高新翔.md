## 活动安排问题
问题描述略
### 三个策略
策略一：选择具有最早开始时间，而且不与已安排的活动冲突的活动。
策略二：选择具有最短使用时间，而且不与已安排的活动冲突的活动。
策略三：选择具有最早结束时间，而且不与已安排的活动冲突的活动。
### 实例分析 -- 采用策略三
对书上的例子进行求解：首先对f[]进行排序，再根据开始时间顺次选取活动，最终得到最优相容解。
![image](https://user-images.githubusercontent.com/30978491/114357462-551f7980-9ba4-11eb-8b52-1f5abeebb17b.png)
### 贪心算法设计
**1、预处理** 选取策略三，对f[]进行生序排列
**2、选择第一个活动** 按照排序结果选取第一个f元素作为第一个活动
**3、贪心** 顺次选择开始时间接在上一个活动结束时间的活动，直到无法填入活动
### 算法实现
```c++
int greedy(int n, int s[], int f[]) {
    int selected, ans = 0;
    sort(f, f+n);  // 对f进行排序
    selected = 0;  // 选取排序后的第一个
    ans = 1;
    for (int i = 1; i < n; i++) // 贪心，直到选完
        if (s[i] >= f[selected]) {
            selected = i; 
            ans++;
        }
    return ans;
}
```
### 算法证明
**证明：贪心算法执行到第 𝑘 步，选择的 𝑘 项活动记为 𝑖1 = 1, 𝑖2, ⋯ , 𝑖𝑘，那么存在一个最优解包含 𝑖1 = 1, 𝑖2, ⋯ , 𝑖𝑘 。**
下使用数学归纳法证明：
① k = 1
用排序完的活动1替换最优解A中的𝑗1，有𝐴′ = {𝐴 − {𝑗1}} ∪ {1}
② k >= 1
假设对于正整数𝑘，命题正确。令{𝑖1 = 1, 𝑖2, ⋯ , 𝑖𝑘} 是GreedySelector算法前𝑘步
顺序选择的活动，那么存在一个最优解 : 𝐴 = {𝑖1 = 1, 𝑖2, ⋯ , 𝑖𝑘} ∪ 𝐵
假设𝑆′ 是S中与{𝑖1 = 1, 𝑖2, ⋯ , 𝑖𝑘}相容的活动，即𝑆′ = {𝑗 ｜ 𝑠[𝑗] ≥ 𝑓 [𝑖𝑘] , 𝑗 ∈ 𝑆 },那么B是𝑺′的一个最优解。
对于子问题𝑆′ 应用基础步的结论：即𝑆′ 的结束时间最早的活动𝑖𝑘+1包含在某一个最优解B′中，则可以构造原问题的一个最优解：
𝐴′ = {𝑖1 = 1, 𝑖2, ⋯ , 𝑖𝑘} ∪ 𝐵′ = 𝒊𝟏 = 𝟏,𝒊𝟐, ⋯ ,𝒊𝒌,𝒊𝒌+𝟏 ∪ {𝐵′ − {𝑖𝑘+1}}

**得证**

