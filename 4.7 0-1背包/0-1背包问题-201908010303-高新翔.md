## 0-1背包问题
### 构造最优子结构
可以得出约束条件为
![image](https://user-images.githubusercontent.com/30978491/113800599-d1bbed80-9789-11eb-9f30-284e0c72bdbb.png)
设*xi*={x1,x2,...,xn}是子问题最优解，则*xi-1*={x1,x2,...,xn-1}是小一级条件下的最优解
#### 下证明成立：
反证法
假设*xi-1*不是小一级条件下的最优解，构造更优解*xi-1'*={x1',x2',....,xn-1'}
根据条件即有∑(i=1,n-1)vi\*xi' > ∑(i=1,n-1)vi\*xi
末尾加上vn\*xn即有∑(i=1,n-1)vi\*xi' + vn\*xn > ∑(i=1,n)vi\*xi，与条件矛盾，故得证。

### 构造递推方程
𝑽𝒂𝒍 (𝒊, 𝒑) , 1 ≤ 𝑖 ≤ 𝑛, 0 ≤ 𝑝 ≤ 𝐶  表示在背包可用容量为𝑝，待考虑装包的物品集为{1, 2, …, i} 时的最大装入物品价值。
此时可以构造递推表达式，分两种情况考虑
#### 有递推方程为
i = 1时，
𝑽𝒂𝒍 (𝒊, 𝒑) = 0, wi > p  或  vi, wi <= p
i > 1时
𝑽𝒂𝒍 (𝒊, 𝒑) = 𝑽𝒂𝒍 (𝒊-1, 𝒑), wi > p 或 max{𝑽𝒂𝒍 (𝒊-1, 𝒑), 𝑽𝒂𝒍 (𝒊-1, 𝒑-wi) + vi}  

*p.s. -wi 是因为可以放入第i个物品，故可用容量减少了wi*

### 自底向上计算最优值
| i \ j | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **1** | 0    | 0    | 6    | 6    | 6    | 6    | 6    | 6    | 6    | 6    | 6    |
| **2** | 0    | 0    | 6    | 6    | 9    | 9    | 9    | 9    | 9    | 9    | 9    |
| **3** | 0    | 0    | 6    | 6    | 9    | 9    | 9    | 9    | 11   | 11   | 14   |
| **4** | 0    | 0    | 6    | 6    | 9    | 9    | 9    | 10   | 11   | 13   | 14   |
| **5** | 0    | 0    | 6    | 6    | 9    | 9    | 12   | 12   | 15   | 15   | 15   |

### 构造最优解
```c++
double binaryKnapsack(int numItems, int *w, double *v, int capacity) {
    int i, p;   // 从1-i个物品，背包可用容量为p
    double Val[n][maxvalue]; // 存储不同情况下的最大容纳容量
    memset(Val, 0, sizeof(Val)); // 初始化
    for (i = 0; i < numItems; i++)  
        for (p = 0; p <= capacity; p++) {  // 根据递推方程进行穷举
            if(p < w[i])
                Val[i][p] = Val[i - 1][p];   // 放不下的情况
            else if (p >= w[i] && Val[i - 1][p] < Val[i - 1][p - w[i]] + v[i])
                Val[i][p] = Val[i][p - w[i]] + v[i]; // 放得下，总容量挖掉w[i]
        }
    return Val[numItems - 1][capacity]; // 得到结果
}
```

