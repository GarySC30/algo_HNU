## 最长公共子序列
### 构造最优子结构
设序列**X={x1, x2... xm}** 和 **Y={y1, y2... ym}** 的最长公共子序列为 **Z={z1, z2, ... zk}**，则
#### 定理（1）若xm = ym，则zk = xm = yn，且zk-1 是 xm-1 和 ym-1 的最长公共子序列。
证明**zk = xm = ym**
反证法：假设zk != xm
构造最长子序列z' = {z1, z2... zk}，由于xm = ym，故序列 {z1, z2, ... zk, xm} 为更长的公共子序列， 且长度为k+1，与题设矛盾，故得证。由于mx = ym，所以zk = xm = ym

证明**zk-1 是 xm-1 和 ym-1 的最长公共子序列**
反证法：假设不是
构造z' = {z1, z2 .... zk}，尾部添加xm后成为长度为k+1的序列，可知这个k+1的序列是最长公共子序列。
而由定义知最长公共子序列的长度为k，故矛盾，得证。

#### 定理（2）若xm != ym，且zk != xm，则Z是xm-1和Y的最长公共子序列
证明
反证法：假设Z不是xm-1和Y的最长公共子序列，故存在更优的最长公共子序列
构造Z' = {Z, 公共元素}，长度为k+1，为公共子序列。
与题设长度为k矛盾，故得证

#### 定理（3）若xm != ym，且zk != yn，则Z是X和ym-1的最长公共子序列
证明略



### 得到递推方程

假设𝐂(𝐢, 𝐣)表示序列𝑋𝑖 = {𝑥1, 𝑥2, ⋯ , 𝑥𝑖} 和𝑌𝑗 = {𝑦1, 𝑦2, ⋯ , 𝑦𝑗} 的最长公共子序列长度

当i = 0 或 𝑗 = 0时，𝐶 𝑖,𝑗 = 0；
当i, j > 0时，𝐶 𝑖,𝑗 的求解包括两种情况：

1. 𝑥𝑖 = 𝑦𝑗时， 𝑋𝑖−1, 𝑌𝑗−1 的最长公共子序列末尾添加元素𝑥𝑖(= 𝑦𝑗)，即可得到 𝑋𝑖, 𝑌𝑗的最长公共子序列
2. 𝑥𝑖 ≠ 𝑦𝑗时， 𝑋𝑖, 𝑌𝑗 的最长公共子序列等于 𝑋𝑖, 𝑌𝑗−1 和 𝑋𝑖−1, 𝑌𝑗 的最长公共子序列的较大者

#### 有递推方程为
![image](https://user-images.githubusercontent.com/30978491/113084514-b17fb200-9210-11eb-8a3c-0ea44094b65b.png)



### 自底向上计算最优值

X = {A,B,C,B,D,A,B}  m = 7

Y = {B,D,C,A,B,A} n = 6

d(B) | 6(A) |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **0**    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| **1(A)** | 0    | 0    | 0    | 0    | 1    | 1    | 1    | 0    | 0    | 1    | 1    | 1    |
| **2(B)** | 0    | 1    | 1    | 1    | 1    | 2    | 2    |
| **3(C)** | 0    | 1    | 1    | 2    | 2    | 2    | 2    |
| **4(B)** | 0    | 1    | 1    | 2    | 2    | 3    | 3    |
| **5(D)** | 0    | 1    | 2    | 2    | 2    | 3    | 3    |
| **6(A)** | 0    | 1    | 2    | 2    | 3    | 3    | 4    |
| **7(B)** | 0    | 1    | 2    | 2    | 3    | 4    | 4    |



### 构造最优解
递推解法
```c++
for (int i = 0; i < m - 1; i++) {
        for (int j = 0; j < n - 1; j++) {
            if (s1[i] == s2[j]) {
                c[i + 1][j + 1] = c[i][j] + 1;
            } else if (c[i][j + 1] >= c[i + 1][j]) {
                c[i + 1][j + 1] = c[i][j + 1];
            } else {
                c[i + 1][j + 1] = c[i + 1][j];
            }
        }
    }
```
由此可求出最长公共子序列的长度。若要求出最长子序列的具体内容，需要开辟另一个数组记录路径信息。